input {
  beats {
    port => 5044
  }
  tcp {
    port => 5000
    codec => json_lines
  }
  udp {
    port => 5000
    codec => json_lines
  }
}

filter {
  if [docker][container][labels][com_docker_compose_project] == "funeral-expenses-payment" {
    # Extract service name from container name
    grok {
      match => { "[docker][container][name]" => "^funeral-expenses-payment_%{WORD:service}_\d+$" }
    }
    
    # Add service-specific processing if needed
    if [service] == "ocr" {
      mutate { add_tag => ["ocr-service"] }
    }
    else if [service] == "semantic" {
      mutate { add_tag => ["semantic-mapping-service"] }
    }
    else if [service] == "upload" {
      mutate { add_tag => ["upload-service"] }
    }
    else if [service] == "mern" {
      mutate { add_tag => ["mern-app"] }
    }
    
    # Parse JSON logs if possible
    json {
      source => "message"
      target => "log_json"
      skip_on_invalid_json => true
    }
    
    # Extract log level if present
    if [log_json][level] {
      mutate { add_field => { "log_level" => "%{[log_json][level]}" } }
    }
    else if [message] =~ "\[ERROR\]" {
      mutate { add_field => { "log_level" => "ERROR" } }
    }
    else if [message] =~ "\[WARN\]" {
      mutate { add_field => { "log_level" => "WARN" } }
    }
    else if [message] =~ "\[INFO\]" {
      mutate { add_field => { "log_level" => "INFO" } }
    }
    else if [message] =~ "\[DEBUG\]" {
      mutate { add_field => { "log_level" => "DEBUG" } }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "funeral-expenses-payment-%{+YYYY.MM.dd}"
  }
  stdout {
    codec => rubydebug
  }
}
